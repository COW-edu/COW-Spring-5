## JPA 개념

### JPA와 JDBC의 차이란?

- JDBC(Java DB Connectivity): 자바에서 DB와 통신하기 위한 가장 기본적 api
  - 역할: 자바 코드로 SQL을 작성하고 직접 실행하며 결과를 받아옴
  - 사용법 -> 직접 SQL문을 작성하고 Connection 등을 수동으로 개발자가 관리해야 함


- JPA(Java Persistence API): 자바 객체를 DB에 저장하고 관리하게 해주는 추상화된 ORM 표준 api
  - 역할: SQL을 직접 작성하지 않고, entity 클래스를 통해 데이터를 관리함
  - 사용법 -> @Entity, @Id, @column과 같은 어노테이션으로 DB 테이블과 객체를 연결함


- 차이점
  - JDBC는 SQL 중심, JPA는 객체(entity) 중심
  - JDBC는 트랜잭션을 수동으로 직접 처리, JPA는 JPA가 트랜잭션을 자동으로 관리해줌
  - 코드 복잡도: JDBC -> 높음 / JPA -> 낮음
  - 유지보수: JDBC가 JPA보다 불편함
  

### ORM이란 무엇이고 JPA가 ORM 프레임워크에서 어떤 역할을 하는지

- ORM(Object-Relational Mapping): 자바 객체(클래스)와 데이터베이스의 테이블을 자동으로 매핑해주는 기술
  - 직접 SQL을 쓰는 대신 자바 객체만 다루면 내부에서 알아서 SQL로 변환해 DB랑 통신해줌


- JPA가 ORM에서 하는 역할
  - entity 매핑 (자바 클래스와 DB 테이블을 연결)
  - CRUD 자동화 (SQL 없이 수행)
  - 트랜잭션을 더 쉽게 처리


- Hibernate: JPA를 구현한 실제 라이브러리

## 엔티티
JPA에서 DB table에 매핑되는 자바 클래스 -> 하나의 entity는 DB의 한 테이블과 1:1로 매칭됨

- DB의 테이블 구조를 자바 객체로 표현해줌
- DB row를 자바 인스턴스로 다룸
- JPA가 entity를 통해 SQL을 자동으로 생성해 DB와 통신함

### 엔티티 필수 어노테이션의 종류는?

- @Entity: 이 클래스가 JPA가 관리할 엔티티임을 선언해줌
- @Id: 엔티티의 pk 지정
- @GeneratedValue: pk의 자동 생성 전략 설정
- @Column: 필드와 테이블의 컬럼을 매핑

### JPA에서 엔티티의 필수 조건은?

1. @Entity 어노테이션 필수
2. 기본 생성자(public / protected)가 있어야 함
3. final 클래스/메서드 사용 금지
4. 필드 또는 프로퍼티의 접근 방식을 일관되게 작성해야 함
5. 식별자 == @Id가 반드시 있어야 함

### 엔티티의 생명주기란?

- 비영속: 엔티티 객체는 생성되었지만 아직 영속성 컨텍스트에 저장되지 않은 상태
- 영속: 영속성 컨텍스트에 저장되어 JPA가 관리하는 상태
- 준영속: 영속성 컨텍스트에서 지운 상태
- 삭제: 실제 DB 삭제를 요청한 상태

## 영속성 컨텍스트

- entity 객체들을 저장하고 관리하는 일종의 메모리 공간
- JPA를 사용해 entity를 DB에 저장하기 전에 항상 영속성 컨텍스트에 먼저 저장해야 함
  - 영속성 컨텍스트에 entity를 저장한다고 해서 DB에 저장되는 것은 아님

- 필요성
  - 같은 트랜잭션 내에서 객체와 DB를 1:1로 연결해 중복 쿼리를 방지함
  - 변경 사항을 추적해 자동으로 DB에 반영할 수 있도록 도와줌

### 영속성 컨텍스트 상태의 종류는?

- 트랜잭션 스코프: 트랜잭션 단위로 영속성 컨텍스트가 생성되고 종료됨
- 확장 스코프: 트랜잭션을 넘어 지속적으로 유지됨

## 연간관계
두 entity 간의 참조 관계 (RDB에서 테이블 간의 fk 관계)

### 연간관계의 종류와 JPA에서의 표현법은?
1. 방향에 따른 분류
   - 단방향 연관관계 (a->b, b는 a를 알지 못함)
   - 양방향 연관관계 (a와 b가 서로 참조가 가능함)
     - 반드시 한 쪽을 연관관계의 주인으로 설정해야 함. (fk를 설정하는 쪽이 한 군데여야하기 때문에)

2. 다중성에 따른 분류
   - 1:1 -> 한 개당 한 개
      ```
      @OneToOne
      @JoinColumn(name="id")
     ```
    
   - 1:n -> 한 개당 여러 개
     ```
     @OneToMany (mappedBy="member")
     ```
     
   - n:1 -> 여러 개가 한 개를 참조 (가장 많이 쓰임)
     ```
     @ManyToOne
     @JoinColumn(name="id")
     ```
      
   - n:m -> 여러 개가 여러 개와 연결 (잘 안쓰임)
     ```
     @ManyToMany
     @JoinTable(name="student_sub", joinCOlumns=@JoinColumn(name="student_id"), inverseJoinColumns = @JoinColumn(name="sub_id"))
     ```
       
