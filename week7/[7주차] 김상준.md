# 7주차 학습 내용

## JPA 개념
### JPA와 JDBC의 차이란?

 JDBC는 자바에서 데이터베이스와 직접 연결하고, SQL 문을 실행하여 데이터를 조회하거나 조작할 수 있도록 해주는 표준 API이다.
따라서 JDBC는 개발자가 SQL을 직접 작성하고, 그 결과를 ResultSet을 통해 받아와서 객체로 수동 변환해야 한다.
반면 JPA는 자바 객체와 데이터베이스 테이블을 매핑해주는 ORM(Object-Relational Mapping) 기술로, 객체 중심으로 데이터를
다룰 수 있게 해준다. JPA는 SQL을 직접 작성하지 않고도 데이터를 저장하거나 조회할 수 있으며, 내부적으로 JDBC를 사용한다.

### ORM이란 무엇이고 JPA가 ORM 프레임워크에서 어떤 역할을 하는지

 ORM이란 객체 지향 프로그래밍 언어의 객체를 관계형 데이터베이스의 테이블과 자동으로 매핑해주는 기술이다.
자바에서 사용하는 클래스와 객체를 DB에서 사용하는 테이블과 레코드로 연결해준다. JPA는 ORM을 위한 자바 표준
API로 자바에서 ORM을 사용할 수 있도록 매핑, 저장, 조회 등의 기능을 인터페이스와 어노테이션을 통해 규격화
해 놓은 것이다.

## 엔티티
### 엔티티 필수 어노테이션의 종류는?
1. `@Entity`
- 목적: 이 어노테이션은 클래스가 엔티티임을 나타낸다. 즉, 이 클래스는 데이터베이스 테이블과 매핑되어야 하는 객체라는 것이다.
- 설명: 엔티티 클래스는 데이터베이스에 저장되는 객체로 변환되어야 하므로 반드시 이 어노테이션이 필요하다.

2. `@Id`
- 목적: 이 어노테이션은 엔티티의 기본 키(primary key)를 나타낸다. 엔티티 객체에서 고유한 식별자를 지정한다.
- 설명: 기본 키는 각 엔티티 객체를 고유하게 식별할 수 있게 해주며, 데이터베이스 테이블에서의 유일성을 보장한다.

3. `@GeneratedValue`
- 목적: 이 어노테이션은 기본 키의 생성 전략을 지정한다. 예를 들어, 자동 증가, 시퀀스 사용 등 여러 가지 전략을 설정할 수 있다.
- 설명: 기본 키의 값을 자동으로 생성할 방법을 지정한다. 예를 들어, 데이터베이스에서 기본 키 값을 자동으로 증가시키거나 특정 전략을 사용할 수 있다.

4. `@Table` (선택적)
- 목적: 이 어노테이션은 엔티티 클래스와 매핑되는 테이블의 이름을 지정한다. 기본적으로 클래스 이름과 동일한 이름의 테이블로 매핑된다. 이름을 변경하고 싶다면 `@Table`을 사용하여 지정할 수 있다.
- 설명: 테이블의 이름을 변경하거나 추가적인 테이블 설정을 할 수 있다. 이 어노테이션은 필수는 아니지만, 테이블 이름을 명시적으로 지정할 때 유용하다.

### JPA에서 엔티티의 필수 조건은?

1. `@Entity` 어노테이션 사용
- 목적: 클래스가 엔티티임을 정의한다. 이 어노테이션을 사용하지 않으면 JPA는 해당 클래스를 엔티티로 인식하지 않는다.
- 설명: 엔티티는 데이터베이스 테이블과 매핑되므로 반드시 `@Entity` 어노테이션을 클래스에 추가해야 한다.

2. 기본 생성자 제공
- 목적: JPA는 리플렉션을 사용하여 엔티티 객체를 생성한다. 기본 생성자가 없으면 객체를 인스턴스화할 수 없다.
- 설명: 기본 생성자는 public 또는 protected 접근 수준을 가져야 하며, 인자 없는 생성자여야 한다.

3. `@Id` 어노테이션 사용
- 목적: 엔티티 클래스의 객체를 고유하게 식별할 수 있도록 하는 필드를 정의한다. `@Id` 어노테이션이 없으면 JPA는 이 클래스를 테이블로 매핑할 수 없다.
- 설명: `@Id` 어노테이션을 사용하여 엔티티의 기본 키(primary key)를 지정한다.

4. 필드 또는 메서드에 대한 매핑
- 목적: 엔티티 클래스의 필드는 테이블의 컬럼에 매핑되어야 한다.
- 설명: 엔티티 클래스의 필드는 자동으로 테이블의 컬럼과 매핑된다. `@Column` 어노테이션을 사용하면 매핑을 세부적으로 조정할 수 있다.

5. `Serializable` 인터페이스 구현
- 목적: 엔티티 객체를 직렬화할 필요가 있을 경우 `Serializable` 인터페이스를 구현해야 한다. 이는 객체를 파일이나 네트워크를 통해 전송할 수 있도록 한다.
- 설명: JPA는 엔티티 객체를 직렬화할 수 있도록 `Serializable` 인터페이스를 구현하는 것을 권장한다.

### 엔티티의 생명주기란?

1. 비영속 상태에서 객체가 생성된다.
2. 객체는 영속 상태로 전이되어 영속성 컨텍스트에 의해 관리되고, 데이터베이스에 저장된다.
3. 이후 객체가 준영속 상태로 전이될 수 있으며, 이 경우 객체는 더 이상 영속성 컨텍스트에 의해 관리되지 않는다.
4. 객체가 삭제 상태로 전이되면, 데이터베이스에서 삭제된다.

## 영속성 컨텍스트
### 영속성 컨텍스트 상태의 종류는?

1. 비영속(Transient) 상태
- 목적: 엔티티 객체가 생성된 직후, 영속성 컨텍스트와 관련이 없는 상태이다.
- 설명: 이 상태에서는 엔티티 객체가 아직 데이터베이스에 저장되지 않았다. 객체는 메모리 내에만 존재하며, `EntityManager`에 의해 관리되지 않는다.

2. 영속(Persistent) 상태
- 목적: 엔티티 객체가 영속성 컨텍스트에 의해 관리되고, 데이터베이스와 매핑되어 있다.
- 설명: `EntityManager`에 의해 관리되는 상태로, 객체는 데이터베이스에 저장되거나 업데이트될 준비가 되어 있다. 
       엔티티가 영속성 컨텍스트에 저장되면, 변경된 내용은 트랜잭션이 커밋될 때 데이터베이스에 반영된다.

3. 준영속(Detached) 상태
- 목적: 엔티티가 영속성 컨텍스트에서 분리된 상태이다.
- 설명: 엔티티가 영속성 컨텍스트와 더 이상 연관되지 않는 상태이다. 이 상태에서는 엔티티 객체가 더 이상 관리되지 않으며,
       데이터베이스의 변경 내용도 반영되지 않는다. 엔티티는 여전히 객체로 존재하지만, 영속성 컨텍스트에서 분리되어 더 이상 자동으로 관리되지 않는다.

4. 삭제(Removed) 상태
- 목적: 엔티티가 영속성 컨텍스트에서 삭제된 상태이다.
- 설명: `EntityManager`에서 삭제 메서드를 호출하여 엔티티를 삭제하면, 해당 엔티티는 데이터베이스에서 삭제된다. 삭제는 트랜잭션이 커밋될 때 실제로 반영된다.


## 연간관계
### 연간관계의 종류와 JPA에서의 표현법은?

1. 1:1 (일대일 관계)
1:1 관계는 한 엔티티가 다른 엔티티와 1:1로 연관될 때 사용된다. 예를 들어, 한 사람은 하나의 여권을 가지고 있고, 여권은 하나의 사람에게만 속하는 경우가 이에 해당한다.

- JPA 표현법:
    - `@OneToOne`: 한 엔티티가 다른 엔티티와 일대일 관계를 맺을 때 사용한다.
    - `@JoinColumn`: 관계가 맺어지는 외래 키를 지정한다.

2. 1:N (일대다 관계)
1:N 관계는 한 엔티티가 다른 엔티티와 1:N으로 연관될 때 사용된다. 예를 들어, 한 부모는 여러 자식을 가질 수 있지만, 각 자식은 하나의 부모만 가진다.

- JPA 표현법:
    - `@OneToMany`: 한 엔티티가 여러 엔티티와 일대다 관계를 맺을 때 사용된다.
    - `@ManyToOne`: 여러 엔티티가 하나의 엔티티와 다대일 관계를 맺을 때 사용된다.
    - `@JoinColumn`: 외래 키를 설정하는데 사용된다.

3. N:1 (다대일 관계)
N:1 관계는 여러 엔티티가 하나의 엔티티와 관계를 맺을 때 사용된다. 예를 들어, 여러 학생이 한 학교에 속할 수 있다.

- JPA 표현법:
    - `@ManyToOne`: 여러 엔티티가 하나의 엔티티와 다대일 관계를 맺을 때 사용된다.
    - `@JoinColumn`: 외래 키를 설정한다.

4. N:N (다대다 관계)
N:N 관계는 여러 엔티티가 여러 엔티티와 관계를 맺을 때 사용된다. 예를 들어, 여러 학생이 여러 강의를 수강하는 경우가 이에 해당한다.

- JPA 표현법:
    - `@ManyToMany`: 여러 엔티티가 다른 여러 엔티티와 다대다 관계를 맺을 때 사용된다.
    - `@JoinTable`: 중간 테이블을 생성하여 관계를 맺을 외래 키를 지정한다.