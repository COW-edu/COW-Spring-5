# 8주차 학습 내용 (CRUD API 연습)

## 이론(공부해서 각 항목 아래에 작성해주세요!)

# REST API

## REST API 개요

REST API는 REpresentational State Transfer의 약자로, 웹에서 자원을 URI를 통해 표현하고, 해당 자원에 대한 상태를
HTTP를 통해 주고받는 방식의 API이다. REST는 웹의 기존 기술과 HTTP 프로토콜을 기반으로 하며, 클라이언트-서버 구조에서
데이터를 교환하는 데 주로 사용된다.

## REST의 제약조건

REST는 다음의 6가지 제약조건을 따른다.

1. 클라이언트-서버 구조 
   클라이언트는 사용자 인터페이스를 담당하고, 서버는 데이터 처리와 저장을 담당한다.

2. 무상태성(Stateless)  
   각 요청은 독립적으로 처리되며, 서버는 클라이언트의 이전 요청 상태를 저장하지 않는다.

3. 캐시 처리 가능 
   서버의 응답은 클라이언트 또는 중간 서버에서 캐시될 수 있으며, 이는 성능 향상에 기여한다.

4. 계층화된 시스템  
   클라이언트는 여러 계층의 서버를 거쳐 최종 서버와 통신할 수 있다.

5. 인터페이스 일관성  
   URI를 통해 자원을 식별하고, HTTP 메서드를 통해 행위를 명확히 표현한다.

6. 코드 온 디맨드 (선택 사항)  
   서버는 필요시 클라이언트에 실행 가능한 코드를 전달할 수 있다.

## REST API 구성 요소

### 자원(Resource)
REST에서는 자원을 URI로 표현한다. 자원은 명사 형태로 정의하며, 고유한 식별자 역할을 한다.

### 행위(Method)
HTTP 메서드를 통해 자원에 대한 행위를 명시한다.

- GET: 자원 조회
- POST: 자원 생성
- PUT: 자원 전체 수정
- PATCH: 자원 일부 수정
- DELETE: 자원 삭제

### 표현(Representation)
서버와 클라이언트 간 데이터 교환은 JSON 또는 XML 형식으로 이루어진다. 표현은 자원의 상태를 전달하는 역할을 한다.


# REST API 설계 주의 점(동사를 써도 되는 경우)
REST API를 설계할 때 일반적으로 URI에는 자원을 명사로 표현하고, 행위는 HTTP 메서드로 표현하는 것이 원칙이다.
그러나 특정한 상황에서는 URI에 동사를 사용하는 것이 더 적절하거나 허용되기도 한다.

## REST API 설계 기본 원칙

REST API는 크게 두 가지 요소로 구성된다.  
첫째, URI는 자원을 가리키는 경로이므로 명사를 사용해야 한다.  
둘째, 자원에 대해 어떤 작업을 할지는 HTTP 메서드(GET, POST, PUT, DELETE 등) 를 사용해서 표현한다.

예를 들어 `/users`라는 자원을 기준으로 다음과 같이 표현할 수 있다:

- `GET /users`는 사용자 목록을 조회한다.
- `POST /users`는 새로운 사용자를 생성한다.
- `PUT /users/1`은 사용자 정보를 수정한다.
- `DELETE /users/1`은 사용자를 삭제한다.

## 동사를 써도 되는 예외적 경우

### 1. 자원이 아닌 '행위' 자체가 자원일 때

로그인, 로그아웃, 비밀번호 재설정, 업로드 같은 기능은 단순한 CRUD가 아니다.  
이들은 자원이라기보다는 업무 처리 과정(프로세스) 이다.

이럴 경우에는 동사를 URI에 명시하는 것이 오히려 명확하다.

예를 들어:

- `POST /users/login` → 로그인 기능을 수행한다.
- `POST /users/logout` → 로그아웃을 처리한다.
- `POST /users/reset-password` → 사용자의 비밀번호를 재설정한다.
- `POST /files/upload` → 파일을 업로드한다.

이런 URI는 동사를 써도 REST 설계 원칙을 크게 해치지 않으며, 사용자도 이해하기 쉽다.

### 2. 특정 자원에 대해 별도의 행위를 수행할 때

일반적인 CRUD 외에, 특정 자원에 대해 추가적인 행동을 해야 하는 경우가 있다.  
예를 들어 주문을 취소하거나, 차량에 기사를 배정하거나, 계정을 인증해야 하는 상황이다.

이때는 URI에 동사를 써서 명확히 표현하는 것이 좋다.

예를 들어:

- `POST /orders/123/cancel` → 주문 번호 123을 취소한다.
- `POST /cars/5/assign-driver` → 차량 5번에 운전기사를 배정한다.
- `POST /accounts/7/verify` → 계정 7번을 인증한다.

이러한 작업은 CRUD를 넘는 비표준적인 행위이므로, URI에 동작을 명시하는 것이 RESTful 설계의 예외로 인정된다.


# HTTP 특징

## 1. 비연결성(Connectionless)

클라이언트가 서버에 요청을 보내면, 서버는 요청을 처리하고 응답을 반환한 뒤 연결을 끊는다.  
즉, 요청-응답이 한 번 완료되면 연결을 유지하지 않는다.  
필요할 때마다 새로운 연결을 만든다.

이 방식은 서버 자원을 효율적으로 사용하게 해주지만, 매 요청마다 연결을 다시 맺어야 하므로 성능에 영향을 줄 수 있다.  
이를 보완하기 위해 HTTP/1.1부터는 Keep-Alive 기능이 도입되어 연결을 일정 시간 유지할 수 있게 했다.

## 2. 무상태성(Stateless)

HTTP는 각 요청 간에 상태 정보를 저장하지 않는다.  
서버는 현재 요청이 이전 요청과 관련 있는지 알지 못한다.  
항상 독립적인 요청으로 간주한다.

이 특성 덕분에 서버가 간단하고 확장성이 높지만, 사용자의 상태(로그인, 장바구니 등)를 관리하려면 쿠키, 세션, 토큰 등의 별도 기술을 사용해야 한다.

## 3. 요청/응답 기반(Request-Response)

HTTP는 클라이언트가 요청을 보내면 서버가 응답하는 구조를 따른다.  
모든 통신은 이 요청-응답 쌍으로 이루어진다.  
서버는 스스로 클라이언트에게 메시지를 보내지 않는다.

예시:
- 클라이언트 → `GET /index.html`
- 서버 → `200 OK + index.html 내용`

## 4. 유연성(Flexible)

HTTP는 텍스트, 이미지, 비디오, JSON, XML 등 다양한 형식의 데이터를 전송할 수 있다.  
`Content-Type` 헤더를 통해 전송되는 데이터의 형식을 지정하면 된다.

예시:
- `Content-Type: text/html` → HTML 문서
- `Content-Type: application/json` → JSON 데이터
- `Content-Type: image/png` → 이미지 파일

## 5. 확장성(Extensible)

HTTP는 헤더 필드(Header Field) 를 통해 다양한 기능을 쉽게 확장할 수 있다.  
캐시, 인증, 압축, 사용자 정의 기능 등을 헤더에 추가하면 유연하게 처리할 수 있다.

예시:
- `Authorization` → 인증 정보
- `Cache-Control` → 캐싱 정책
- `Accept-Encoding` → 압축 방식 지정

## 6. 단순함(Simple)

HTTP는 구조가 단순하다.  
텍스트 기반이기 때문에 사람이 읽고 해석하기 쉽고, 디버깅도 간단하다.

요청 메시지와 응답 메시지 모두 다음과 같은 구조를 가진다:
- 시작줄 (Start Line)
- 헤더 (Header)
- 본문 (Body, 선택적)

## 7. 포트 번호

- 기본 포트는 `80번(HTTP)`과 `443번(HTTPS)`을 사용한다.
- HTTPS는 HTTP에 SSL/TLS 보안 계층이 추가된 버전이다.

## 8. 클라이언트-서버 구조

HTTP는 클라이언트-서버 아키텍처를 따른다.  
클라이언트는 요청을 보내는 쪽(브라우저, 앱 등), 서버는 응답을 제공하는 쪽이다.  
양쪽의 역할이 명확히 구분되어 있다.


# HTTP 메소드 8가지

## 1. GET

- 서버에서 자원을 조회할 때 사용한다.
- 요청에 본문(body)이 없으며, URL에 필요한 정보를 담아서 보낸다.
- 안전하고 멱등성이 있다. (즉, 여러 번 호출해도 서버 상태가 변하지 않는다.)
- 예) 웹페이지 조회, 데이터 조회 등

## 2. POST

- 서버에 새로운 자원을 생성하거나 서버에서 처리해야 하는 작업을 요청할 때 사용한다.
- 요청 본문에 데이터를 포함하여 보낸다.
- 멱등성이 없으므로, 여러 번 요청하면 여러 개가 생성될 수 있다.
- 예) 회원 가입, 글 작성, 파일 업로드 등
- 
## 3. PUT

- 서버에 존재하는 자원을 수정하거나 새로 생성할 때 사용한다.
- 요청 본문에 수정할 전체 데이터를 포함한다.
- 멱등성이 있다. (여러 번 요청해도 결과가 같다.)
- 예) 사용자 정보 수정, 문서 전체 업데이트 등

## 4. DELETE

- 서버의 자원을 삭제할 때 사용한다.
- 멱등성이 있다. (여러 번 삭제 요청해도 동일한 결과)
- 예) 게시글 삭제, 파일 삭제 등

## 5. PATCH

- 서버 자원의 일부를 부분적으로 수정할 때 사용한다.
- PUT과 달리 전체가 아닌 변경할 부분만 보낸다.
- 멱등성이 있지만 구현에 따라 다를 수 있다.
- 예) 사용자 프로필 중 일부 필드만 변경할 때

## 6. HEAD

- GET 요청과 동일하지만, 응답 본문을 제외하고 헤더만 받아온다.
- 리소스가 존재하는지, 변경되었는지 등의 정보를 확인할 때 유용하다.
- 예) 캐시 유효성 검사, 리소스 상태 점검

## 7. OPTIONS

- 서버가 지원하는 HTTP 메소드나 기능을 확인할 때 사용한다.
- 주로 CORS(Cross-Origin Resource Sharing) 정책 확인에 쓰인다.
- 예) 특정 URI가 어떤 메소드를 허용하는지 요청할 때

## 8. TRACE

- 서버가 클라이언트로 요청을 받은 내용을 그대로 되돌려주는(반사하는) 용도이다.
- 디버깅이나 테스트 목적으로 사용하지만 보안 이슈 때문에 자주 사용하지 않는다.



# DB
## 정규화 3단계
1단계: 중복이 없어야 한다.

2단계: 1단계를 만족하고 partialfuntionaldependency가 없어야 한다.

3단계: 2단계를 만족하고 transitivefuntionaldependency가 없어야 한다.
  
## 관계 유형
1 : 1
- 한 테이블의 한 행(row)이 다른 테이블의 한 행과 정확히 1:1로 대응한다.
 
1 : M
- 한 테이블의 한 행이 다른 테이블의 여러 행과 대응한다.
  
M : M
- 한 테이블의 여러 행이 다른 테이블의 여러 행과 대응한다.

## PK, FK
PK: 테이블 내에서 각 행(row)을 유일하게 식별하는 컬럼(또는 컬럼 집합) 이다.  
FK: 한 테이블의 컬럼이 다른 테이블의 기본 키(PK)를 참조하는 키이다.  

