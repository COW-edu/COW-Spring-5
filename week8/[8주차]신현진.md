### REST API
REST: REpresentational State Transfer

- REST 구성
  - 자원: URI
  - 행위: HTTP Method(GET, POST, PATCH, DELETE)
  - 표현: Representation
    - 어떤 자원의 특정 시점의 상태를 반영하고 있는 정보

-> 자원을 이름(=자원의 표현)으로 구분해 해당 자원의 상태를 주고 받는 모든 것
=> 자원의 표현에 의한 상태 전달

- REST API: REST 규칙을 지킨 API

### REST API 설계 주의점 (동사를 써도 되는 경우)
- URI는 정보의 자원을 표현해야 한다.
  - `/createUser` (X)  `/users` (O)
- 자원은 복수형을 사용한다.
- 계층적으로 구조표현을 한다.
  - `/users/123/orders/456`
- 필터링, 페이지네이션 등은 쿼리 파라미터를 통한다.
- 에러처리에 명확한 HTTP 상태코드를 사용한다.
- 자원에 대한 행위는 HTTP Method로 표현한다.
  - 행위는 URI에 포함하지 않는다.

    
- **동사를 써도 되는 경우**
  - 특수한 행위나 행동 자체가 목적일 때
  - POST `/orders/456/cancel`

### HTTP 특징
- 클라이언트 서버 구조
  - 클라이언트는 서버에 Request를 보내고, Response를 대기한다.
  - 서버가 Request에 대한 결과를 만들어 Response한다.
  
  -> 양쪽이 독립적으로 진행할 수 있다.


- stateless(무상태): 서버가 클라이언트의 상태를 보존하지 않음
  - 고객: 이 토마토 얼마에요?
    - 점원: 100만원이에요
  - 고객: 토마토 2개 구매할게요
    - 점원: 토마토 2개는 200만원이에요
    
  -> 요청할 때 필요한 데이터를 모두 포함해서 서버에게 요청하게 됨
  
  - 특징
    - 갑자기 클라이언트의 요청이 증가해도 서버를 많이 투입할 수 있음
    - 응답 서버를 쉽게 바꿀 수 있음
  - 한계
    - 모든 것을 stateless로 설계할 수 있는 경우도 있고 없는 경우도 있음
      - stateless: 서비스 소개 화면
      - stateful: 로그인
    - 데이터를 너무 많이 보냄


- Connectionless(비연결성)
  - 자원에 대한 요청을 주고 받을 때만 연결을 유지해 최소한으로 사용하고, 클라이언트와 요청-응답 과정 후 연결을 끊음
  
  -> 서버 자원을 효율적으로 사용할 수 있음
  
  - 한계
    - TCP/IP 연결을 새로 맺어야 하기 때문에 3way handshake 시간이 추가됨
    -> HTTP 지속 연결(Persistent Connections)로 문제를 해결함


- 단순하고 확장이 가능함

### HTTP 메소드 8가지
- GET: 자원 조회
  - 서버 상태를 바꾸지 않음
  - 멱등성 가짐 (여러 번 호출해도 결과가 같음)
- POST: 주로 등록에 사용함
  - 비멱등성 가짐 (같은 요청을 여러 번 시도하면 자원의 중복 생성이 가능)
- PUT: 자원을 대체하고, 해당하는 자원이 없다면 새로 생성
- PATCH: 자원을 부분적으로 변경함
- DELETE: 자원 삭제
- HEAD: GET 요청과 동일하지만 body를 제외한 헤더 정보만 응답해줌
- OPTIONS: 요청 가능한 HTTP 메서드 목록을 조회
  - 서버가 허용하는 동작을 확인하기 위한 용도로 사용
- TRACE: 클라이언트 -> 서버로 가는 요청을 그대로 반사해 확인
  - 경로를 추적해 네트워크 문제를 확인하는데, 실제 사용은 거의 없음

### DB

#### 정규화 3단계
1. 1NF(Normal Form)
   - 각 컬럼은 더 이상 쪼갤 수 없는 원자값만 가져야 함 -> 하나의 셀에는 하나의 값만 존재해야 함
2. 2NF
   - 1NF를 만족하면서 기본 키의 부분 집합에 종속된 속성을 제거
   - ex) 과목명은 과목 코드에만 종속되어있고 학번과는 무관한데 하나의 테이블에 학번,과목코드,과목명이 함께 있다면
     (PK = 학번, 과목 코드)
     -> 학번-과목 코드 테이블/과목코드-과목명 테이블로 분리

3. 3NF
   - 2NF를 만족하면서 기본 키가 아닌 컬럼에 의해 결정되는 다른 컬럼을 제거
   - ex) 부서명은 부서 ID에 의해 결정되는데 한 테이블에 사원 ID, 부서 ID, 부서명이 있다면
     (PK = 사원 ID)
     -> 사원 ID-부서 ID 테이블/부서 ID-부서명 테이블로 분리
   

#### 1:1
- A 테이블의 하나의 레코드는 B 테이블의 하나의 레코드와 정확히 연결됨

    ex) 한 사람은 하나의 주민등록증만 가짐

#### 1:M
- A 테이블의 하나의 레코드는 B 테이블의 여러 레코드와 연결될 수 있음

    ex) 한 고객이 여러 개의 주문을 할 수 있음

#### M:N
- A와 B 테이블 각각의 레코드가 서로 여러 개와 연결될 수 있음

    ex) 학생은 여러 강의를 들을 수 있고, 한 강의에 여러 학생이 참여할 수 있음

#### PK, FK
- PK(Primary Key): 테이블 내에서 각 row를 유일하게 식별하는 컬럼
  - 특징
    - 유일성: 중복된 값이 없어야 함
    - null값이 될 수 없음
    - 하나의 테이블에 한 개만 존재할 수 있음
      - 여러 컬럼을 조합해서 만들 수도 있음 (복합 PK)


- FK(Foreign Key): 다른 테이블의 PK를 참조하는 컬럼
  - 테이블 간의 관계를 나타내기 위해서 사용
  - 특징
    - 참조 무결성 유지: 존재하지 않는 PK 값을 FK로 가질 수 없음
    - null이나 중복 가능
    - 하나의 테이블에 여러 개 존재할 수 있음
