# 3주차 학습 내용

—

## **1. 의존성 주입 종류 알아오기**

생성자 주입: 생성자 주입은 필요한 의존 관계를 생성자를 통해 주입 받는 방식이다.

@Component
public class CarService {

    private final Engine engine;

    @Autowired
    public CarService(Engine engine) {
        this.engine = engine;
    }
}

 생성시에 의존성을 주입하므로 의존 객체가 존재하지 않는다면 생성되지 않는다. 이를 통해 객체의 주입을 강제할 수 있으며
메서드를 통해 주입되지 않기 때문에 주입된 객체의 불변성이 보장된다.


수정자 주입: 수정자 주입은 필드값을 변경하는 setter 메서드를 통해 의존 관계를 주입 받는 방식이다.

@Component
public class MyService {

    private MyRepository repo;

    @Autowired
    public void setRepo(MyRepository repo) {
        this.repo = repo;
    }
}

 수정자 주입은 생성자 주입과 달리 주입 받은 객체를 변경할 수 있다. 따라서 이러한 변경 기능이 필요할 때는 수정자 주입을 사용하나
변경 과정에서 잘못된 값이 들어가거나, 혹은 주입 받기 전에 해당 필드를 사용한다면 문제가 생길 수 있기 때문에 대부분의 경우 생성자
주입을 사용한다.


필드 주입: 필드 주입은 필드에 바로 의존 관계를 주입하는 방식이다.

@Component
public class MyService {

    @Autowired
    private MyRepository repo;
}

 필드 주입은 스프링 내부에서 리플렉션을 통해 필드에 강제로 접근 가능하게끔 만들면서 직접 값을 주입하는 식으로 이루어진다.  
가장 간단한 방식이고 코드가 짧다는 장점이 있으나 테스트가 어렵고 외부에서 의존성에 접근하기 어렵다는 단점이 있다.
그뿐만 아니라 스프링 컨테이너에 강하게 결합된다거나 순수 자바 환경에서 동작이 불가능하다는 단점도 있다. 따라서 필드 주입은
최대한 지양하는 것이 좋다.


일반 메서드 주입: 일반 메서드 주입은 setter를 이용한 수정자 주입과 거의 같으나 메서드명을 set으로 강제하지 않아도 된다는 점이 다르다.


## **2. 스프링 사용 이유 공부**

 단적으로 이야기하면 자바로 개발을 할 때 자주 들어가는 작업들을 프레임워크가 대신 처리해주고
더 쉽게 만들어준다고 볼 수 있을 것 같다.

의존성 주입
- 객체 간의 의존 관계를 스프링이 자동으로 주입해 준다.

제어의 역전
- 객체 생성과 관리를 개발자가 아닌 스프링이 담당한다.

모듏화 및 유지보수 용이
- 관심사 분리를 통해 각 기능을 나눠서 관리하는 것이 가능하다.

관점 지향 프로그래밍 지원
- AOP를 지원하여 로깅, 트랜잭션, 보안 등 공통 기능을 핵심 로직과 분리하여 적용이 가능하다.

테스트 용이성
- DI와 빈 관리 덕분에 단위 테스트와 통합 테스트가 쉽다.


## **3.  스프링 컨테이너 알아오기**

 위에서 스프링 사용 이유에서 말했던 스프링이 자동화 해주는 작업들은 모두 컨테이너에서 중점적으로 관리하며 
컨테이너와 컨테이너에 연결된 모듈을 통해 자동화가 된다. 컨테이너는 빈 객체를 단위로 관리하는데 일반적인
클래스 앞에 @Component 를 붙이면 컨테이너에서 그 클래스를 인스턴스화 시켜 컨테이너에서 싱글톤으로 관리한다.
컨테이너는 빈 객체의 생명주기를 관리하며 그 외 의존성 주입, AOP, 로깅, 트랜잭션 등의 작업을 처리한다.