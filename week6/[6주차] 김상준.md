# 6주차 학습 내용

### Spring MVC Lifecycle

1. 클라이언트 → 요청 전송
- 브라우저에서 `GET /users/1` 같은 요청을 보냄.

2. DispatcherServlet이 요청을 받음
- 스프링의 중앙 컨트롤러(프론트 컨트롤러) 역할
- 모든 요청은 DispatcherServlet이 가장 먼저 받음.

3. HandlerMapping → 요청에 맞는 컨트롤러 찾기
- DispatcherServlet은 어떤 컨트롤러가 이 요청을 처리할지 찾음
- URL, 메서드(GET/POST) 등을 기반으로 매핑.

4. Controller 호출
- 매핑된 컨트롤러의 메서드 실행.
- 예시: `UserController.getUser()` 호출.

5. Controller → Service 호출
- 컨트롤러는 비즈니스 로직은 서비스에 위임.
- 서비스는 필요하면 Repository(DAO)를 통해 DB 조회/저장.

6. Controller → ModelAndView 반환 (View 이름 + 데이터)
- 컨트롤러는 처리 결과를 Model (데이터)와 View 이름으로 반환.

7. ViewResolver → View 찾기
- View 이름을 받아 실제 JSP, Thymeleaf 등 View 파일을 찾음.

8. View 렌더링
- View 파일에 Model 데이터를 바인딩해서 최종 HTML 생성.

9. DispatcherServlet → 클라이언트에 응답 반환
- 최종 HTML을 클라이언트로 반환.

### Dispatcher servlet의 역할

Spring MVC에서 DispatcherServlet은 요청과 응답을 처리하는 중앙 컨트롤러(Front Controller)로 동작한다.

1. 클라이언트의 모든 요청을 가장 먼저 받는다
- 사용자가 브라우저를 통해 보낸 HTTP 요청은 모두 DispatcherServlet을 거친다.
- 웹 애플리케이션의 진입점 역할.

2. HandlerMapping을 통해 요청에 맞는 Controller를 찾는다
- URL, HTTP 메서드(GET/POST 등)를 기반으로 어떤 Controller가 요청을 처리할지 매핑 정보를 조회.
- HandlerMapping 객체를 사용해 매핑된 Controller를 찾는다.

3. Controller를 호출한다
- 매핑된 Controller의 메서드를 실행하여 요청 처리를 위임한다.
- Controller는 요청 파라미터를 바탕으로 비즈니스 로직을 처리하거나 Service, Repository를 호출한다.

4. Controller의 처리 결과(ModelAndView)를 받는다
- Controller는 View 이름과 Model 데이터를 담은 ModelAndView 객체를 반환한다.
- DispatcherServlet은 이 결과를 받는다.

5. ViewResolver를 통해 View를 찾는다
- 반환된 View 이름을 기반으로 실제 View 파일 경로(JSP, Thymeleaf 등)를 찾기 위해 ViewResolver를 사용한다.

6. View를 렌더링한다
- View에 Model 데이터를 전달하여 하고 메서드를 호출하여 HTML 등의 최종 응답을 생성한다.

7. 생성된 응답을 클라이언트에 반환한다
- 최종 HTML 등의 응답을 클라이언트(브라우저)로 전송한다.

### Bean이란?

 객체 생성, 의존성 주입, 생명주기 관리 등을 Spring에서 대신 수행하기 위해서 어노테이션 등을 통해 클래스를
Spring 컨테이너에 등록하여 관리하는 객체이다.

### Bean Lifecycle

1. 빈 생성 (Instantiation)
- 스프링 컨테이너가 빈 객체를 생성 (new)
- `@Component`, `@Bean`, `<bean>` 등으로 등록된 클래스를 기반으로 객체를 생성
- 아직 의존성 주입은 이루어지지 않음

2. 의존성 주입 (Dependency Injection)
- 빈 내부에 필요한 의존 객체들을 주입
- `@Autowired`, 생성자 주입, 세터 주입 등을 통해 의존성을 주입
- 이 시점부터 객체가 필요한 모든 의존성을 갖추게 됨

3. 초기화 (Initialization)
- 빈 객체가 초기화 콜백 메서드를 호출받는 단계
- 예시:
    - `@PostConstruct` 메서드 실행
    - `InitializingBean` 인터페이스의 `afterPropertiesSet()` 실행
    - `init-method` 에 지정된 메서드 실행
- 초기 설정이나 리소스 연결 등 초기 작업 수행

4. 사용 (Ready for use)
- 빈이 완전히 초기화되어 클라이언트 코드에 사용될 준비 완료
- 컨트롤러, 서비스, DAO, 다른 빈에서 사용
- 이 시점부터 스프링 빈은 애플리케이션 내에서 사용 가능

5. 소멸 (Destruction)
- 스프링 컨테이너 종료 시 빈도 함께 소멸
- 리소스 반환, 연결 해제 등 정리 작업 수행
- 예시:
    - `@PreDestroy` 메서드 실행
    - `DisposableBean` 인터페이스의 `destroy()` 메서드 실행
    - `destroy-method` 에 지정된 메서드 실행
- 메모리 릴리즈, 파일 닫기, DB 연결 종료 등의 작업 수행

### Spring 어노테이션 10가지와 그에 대한 설명

1. @Component
- 해당 클래스가 스프링 컨테이너에 의해 관리되는 빈(Bean)임을 표시
- 일반적인 컴포넌트 클래스를 정의할 때 사용

2. @Controller
- 이 클래스가 웹 요청을 처리하는 컨트롤러임을 나타냄
- Spring MVC에서 사용

3. @Service
- 해당 클래스가 서비스 계층의 컴포넌트임을 나타냄
- 비즈니스 로직을 처리하는 클래스에 사용

4. @Repository
- 해당 클래스가 데이터 접근 계층(DAO)임을 나타냄
- 데이터 접근 관련 예외를 Spring의 DataAccessException으로 변환

5. @Autowired
- 의존성 주입(DI)을 위해 사용
- 필요한 빈을 자동으로 주입받음

6. @Qualifier
- `@Autowired` 사용 시, 같은 타입의 빈이 여러 개 있을 때 구체적인 빈 이름을 지정

7. @RequestMapping
- HTTP 요청 URL을 컨트롤러 메서드에 매핑
- GET, POST 등 모든 요청에 사용 가능

8. @GetMapping / @PostMapping
- `@RequestMapping`의 축약형으로 각각 GET / POST 요청에 사용

9. @Bean
- 개발자가 직접 스프링 컨테이너에 Bean 등록할 때 사용
- 설정 클래스 내부에서 사용

10. @Configuration
- 해당 클래스가 스프링 설정 클래스임을 나타냄
- `@Bean` 정의를 포함하는 클래스

### Spring 의존성 주입 방식

1. 생성자 주입 (Constructor Injection)
- 생성자를 통해 의존성을 주입받는 방식
- 불변성을 보장하고, 주입받는 객체가 반드시 필요할 때 권장

장점
- `final` 사용 가능 → 필수 의존성 보장
- 테스트 시 Mock 주입 용이

단점
- 순환 참조 발생 시 문제 가능성

2. 세터 주입 (Setter Injection)
- 세터 메서드를 통해 의존성을 주입받는 방식
- 선택적 의존성이나 나중에 의존성을 바꿔야 할 때 사용

장점
- 의존성 선택적 주입 가능
- 필요 시 의존성 교체 가능

단점
- 객체 생성 후에도 의존성이 없을 수 있음 → 불완전한 상태 가능성

3. 필드 주입 (Field Injection)
- 필드에 직접 `@Autowired`를 붙여 의존성을 주입받는 방식
- 코드가 간단하지만, 테스트나 유지보수 측면에서 권장되지 않음

장점
- 가장 간단함 (코드 짧음)

단점
- 테스트에서 의존성 주입 어려움
- `final` 사용 불가
- 스프링 컨테이너 없이 순수 자바 코드로 테스트 어려움

### 생성자 주입 방식(중요)

1. 스프링 컨테이너 초기화
  - `ApplicationContext` 또는 `AnnotationConfigApplicationContext` 등으로 스프링 컨테이너가 생성됨
  - `@ComponentScan`, `@Bean`, `@Configuration` 등으로 등록된 클래스 정보를 읽어옴

2. 빈 정의 확인
  - `@Component`, `@Service`, `@Repository` 등으로 등록된 클래스들을 빈 정의(Bean Definition)로 파악
  - 해당 클래스의 생성자 정보를 확인

3. 생성자 파라미터 분석
  - 생성자가 있다면, 해당 생성자에 필요한 파라미터 타입을 확인
  - 생성자 파라미터로 요구하는 의존성 객체(타입)에 맞는 다른 빈을 컨테이너에서 찾음

4. 의존성 주입
  - 찾은 빈(의존성 객체)을 생성자 인자로 넣어서 객체를 생성(인스턴스화)
  - 이렇게 생성된 객체를 스프링 컨테이너에 등록







