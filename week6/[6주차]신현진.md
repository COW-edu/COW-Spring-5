### Spring MVC Lifecycle
(Request) => Filter -> DispatcherServlet -> HandlerMapping -> HandlerInterceptor -> Controller -> Service -> Repository -> ViewResolver


- **Filter**
  - 웹 요청이 들어올 때 맨 처음 가로채서, 필요한 검사나 설정을 하고 난 후 다음 단계로 넘기는 역할
    - 인증/인가: 로그인 했는지 확인 후, 안했으면 리다이렉트
    - 로깅: 요청 URL, 요청자 IP 등을 로그로 남김
    - 인코딩 설정
    - 보안 검사: XSS나 SQL Injection에 대한 간단 필터링
      - SQL Injection: 사용자가 쿼리문 안에 악의적인 코드를 주입해 DB를 속이는 공격
    - CORS 설정


- **DispatcherServlet**
  - HandlerMapping에게 요청을 어떤 Controller가 처리해야 하는지를 물어봄
  - HandlerMapping이 알려준 Controller를 호출함

- **HandlerMapping**
  - DispatcherServlet이 받은 요청에 대해 어떤 Controller가 처리할지를 결정함

- **HandlerInterceptor**
  - Controller 앞에 있는 문지기 역할
  - 다음 타이밍에 개입 가능
    - preHandle(): 컨트롤러가 실행되기 직전
    - posthandle(): 컨트롤러 실행 직후, 뷰 렌더링 전
    - afterCompletion(): 뷰 렌더링까지 완료된 후
  
  - 흐름 순서
    - 요청 -> Filter -> DispatcherServlet -> HandlerInterceptor (preHandle) -> Controller 실행 -> HandlerInterceptor (postHandle) -> View 렌더링 -> HandlerInterceptor (afterCompletion) -> 응답 반환
  
- **Controller**
  - 요청과 매핑되는 곳
  - 어떤 로직으로 처리할 것인지 결정하고 그에 맞는 Service를 호출함

- **Service**
  - 데이터 처리 및 가공을 위한 비즈니스 로직을 수행
  - 요청에 대한 실질적인 로직을 수행함
  - Repository를 통해 DB에 접근해 데이터의 CRUD를 처리함

- **Repository**
  - DB에 접근하는 객체
  - DAO(Data Access Ovject)의 발전된 개념
    - DB 접근 뿐 아니라 도메인 중심 아키텍처에 어울리게 설계된 Spring 스타일의 DAO
  - Service에서 DB에 접근할 수 있게 해 데이터의 CRUD를 도와줌

- **ViewResolver**
  - Controller에서 준 뷰의 이름을 DispatcherServlet으로부터 넘겨받음
  - 해당 뷰를 렌더링하고 DispatcherServlet으로 리턴
    - DispatcherServlet에서는 해당 뷰 화면을 응답
  - View 없이 데이터만 전달하는 경우 ViewResolver는 불필요함
  

### Dispatcher servlet의 역할
1. 요청 수신
    - 클라이언트의 HTTP 요청을 Filter 다음으로 받음
2. 요청 URL에 따라 HandlerMapping에게 어떤 Controller가 해당 요청을 처리할지 물어봄
3. HandlerAdapter 호출
    - 해당 Controller를 실제로 실행할 수 있는 방법을 HandlerAdapter에게 위임해 호출함
4. Controller 실행
5. ViewResolver로 어떤 화면을 보여줄지 결정
6. 클라이언트에게 최종 응답

### Bean이란?
스프링이 관리하는 객체(인스턴스)
- 개발자가 new 키워드로 직접 만드는 객체가 아니라 스프링이 자동으로 생성하고 관리하는 객체


- 특징
  - 객체의 생명주기를 스프링이 책임짐
  - 필요할 때 자동 주입 가능
  - 전역적으로 공유되어 사용됨

```
@Component // Bean으로 등록됨
public class UserService {
    ...
}

```

```
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```


### Bean Lifecycle
스프링 컨테이너가 Bean을 생성/초기화/사용/소멸시키기까지의 전 과정

1. 객체 생성
   - 스프링이 객체 인스턴스를 만듦
2. 의존성 주입
   - @Autowired, 생성자 주입 등을 통해 필요한 의존 객체를 주입
3. 초기화
   - 초기 설정 작업 진행
4. 사용
   - 실제로 해당 Bean을 다른 컴포넌트에서 사용
5. 소멸
   - @PreDstrosy 등이 호출되어 정리 작업이 수행됨


### Spring 어노테이션 10가지와 그에 대한 설명
**@Component**
- 스프링이 Bean으로 등록할 수 있게 해주는 클래스 표시용 어노테이션

**@Service**
- 비즈니스 로직을 담는 서비스 계층 클래스에 붙임
  - 내부적으로는 @Component와 같지만 의미적으로 구분함

**@Repository**
- DAO 역할을 하는 클래스에 붙임
  - @Component와 같지만, 데이터 접근 예외를 스프링 예외로 변환해줌

**@Controller**
- 웹 요청을 처리하는 클래스에 붙임
- 스프링 MVC에서 클라이언트 요청을 받는 진입점

**@RestController**
- @Controller + @ResponseBody
- JSON 형태로 데이터를 반환하는 API 작성 시 사용

**@Autowired**
- 필요한 Bean을 자동 주입
- 생성자, 필드, 메서드에 붙일 수 있음

**@Qualifier**
- @Autowired와 함께 사용할 때, 여러 Bean 중 어떤 Bean을 주입할 지 이름으로 지정함

**@Value**
- 환경 변수에서 값을 읽어 주입할 때 사용

**@Configuration**
- 설정 클래스를 나타냄
- 내부에서 @Bean을 사용해 수동으로 Bean을 등록하는 것이 가능

**@Bean**
- 메서드에 붙임
  - 직접 생성한 객체를 Bean으로 등록할 때 사용
- @Configuration 클래스 내부에서 사용함


### Spring 의존성 주입 방식
### 생성자 주입 방식(중요)
